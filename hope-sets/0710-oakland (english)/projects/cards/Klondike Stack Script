on Deal  if exists(cd grp "moveGroup") then    set the members of cd grp "moveGroup" to empty    hide cd grp "moveGroup"      end if  ClearPiles    ShowStatus "Gathering Cards"  HideCards CardList()    put Shuffle() into cardList  put DealList() into dealList  put the number of lines of dealList into lastDealtCard    StartProgress CardCount(),"Dealing"  repeat with i = 1 to lastDealtCard    ShowProgress    QuickMove "cd grp "&(item 1 of line i of dealList), line i of cardList, (item 2 of line i of dealList)  end repeat    delete line 1 to lastDealtCard of cardList  QuickAssign "cd grp stock", cardList, "down"  ClearProgress    ShowStatus "Showing cards"  ShowCards  ClearStatus  ClearUndoStack  set the cursor to browseend Dealfunction StockLoc  return PileLoc("cd grp stock")end StockLocon ClearPiles pileList  if pileList is empty then put PileList() into pileList  repeat with i = 1 to the number of lines of pileList    set the cardList of (line i of pileList) to empty    end repeat  end ClearPileson ShowDealList theState  if theState is empty then put true into theState    set the visible of bg dsht "dealList" to theStateend ShowDealListon HideDealList   ShowDealList false  end HideDealListfunction DealList newList  if newList is not empty then put StripReturns(newList) into bg dsht "dealList"  return bg dsht "DealList"end DealListfunction SlotList  return the list of cd grps with property IsASlotend SlotListfunction GoalList  return the list of cd grps with property IsAGoal end GoalListfunction PileType thePile, newType  if newType is not empty then set the IsAPile of thePile to newType  return the IsAPile of thePileend PileTypefunction BasePileList newList  if newList is not empty then put newList into bg dsht "pileList"  return bg dsht "pileList"  end BasePileListon ShowPileList theState  if theState is empty then put true into theState    set the visible of bg dsht "pileList" to theState  end ShowPileListon HidePileList  ShowPileList false  end HidePileListon SetPileList  put the list of cd groups with property IsAPile into pileList    repeat with i = 1 to the number of lines of pileList    put line i of pileList into thisPile    put the short name of thisPile &","&the rect of thisPile &","&the style of thisPile Â&","&the textFont of thisPile &","&the textSize of thisPile &","&the textAlign of thisPileÂ&","&PileType(thisPile)&","&the hoffset of thisPile&","&the voffset of thisPile into line i of pileList  end repeat      get BasePileList(pileList)end SetPileListfunction PileList theType  put the list of cd grps with property IsAPile into pileList  if theType is empty then return pileList    repeat with i = the number of lines of pileList down to 1    if the IsAPile of (line i of pileList) is not theType then delete line i of pileList    end repeat  return StripReturns(pileList)  end PileListon DeletePiles  put the list of cd grps with property IsAPile into pileList    repeat with i = the number of lines of pileList down to 1    do "delete "&line i of pileList  end repeat  end DeletePileson MakePiles  put BasePileList() into pileList    repeat with i = the number of lines of pileList down to 1    put line i of pileList into thisPile    put item 1 of thisPile into pileName    put item 2 to 5 of thisPile into pileRect    put item 6 of thisPile into pileStyle    put item 7 of thisPile into pileFont    put item 8 of thisPile into pileSize    put item 9 of thisPile into pileAlign    put item 10 of thisPile into pileType    put item 11 of thisPile into hoffset    put item 12 of thisPile into voffset        create card group    send last card group to back        add property IsAPile to first cd grp    add property CardList to first cd grp      add property hoffset to first cd grp    add property voffset to first cd grp    set the name of first cd grp to pileName    set the rect of first cd grp to pileRect      if pileStyle is not empty then set the style of first cd grp to pileStyle    if pileFont is not empty then set the textFont of first cd grp to pileFont    if pileSize is not empty then set the textSize of first cd grp to pileSize    if pileAlign is not empty then set the textAlign of first cd grp to pileAlign    get PileType("first cd grp",pileType)      set the hoffset of first cd grp to hoffset    set the voffset of first cd grp to voffset        show first cd grp  end repeat    end MakePileson newCard  add property StartConfiguration to this card  add property DeckCount to this card  add property WildCards to this cardend newCardon QuickAssign thePile, theCards, theDirection  put the cardList of thePile into pileList    repeat with i = the number of lines of theCards down to 1      ShowProgress    put line i of theCards into theCard    if theDirection is empty then put "down" into theDirection    set the isACard of theCard to theDirection    put return & the id of theCard after pileList      set the pile of theCard to thePile    set the loc of theCard to PileLoc(thePile)      bring theCard to front  end repeat  if char 1 of pilelist is return then delete char 1 of pileList  set the cardList of thePile to pileListend QuickAssignon QuickMove thePile, theCard, theDirection  --  hide theCard  if theDirection is empty then put "down" into theDirection  set the isACard of theCard to theDirection  get the cardList of thePile  put the id of theCard into line (the number of lines of it + 1) of it  set the cardList of thePile to it  set the pile of theCard to thePile  bring theCard to front  set the loc of theCard to PileLoc(thePile)    if theDirection is "Down" then do "put bg bmp back into "&theCard  else do "put bg bmp "&quote&the short name of theCard&quote&" into "&theCard    --  show theCardend QuickMovefunction PileLoc thePile, pileCount  put the loc of thePile into pileLoc  put the top of thePile + 45 into item 2 of pileLoc  if pileCount is empty then put the number of lines of the cardList of thePile  into pileCount  add (the hoffset of thePile * (pileCount - 1)) to item 1 of pileLoc  add (the voffset of thePile * (pileCount - 1)) to item 2 of pileLoc  return pileLocend PileLocfunction FlipTopCard thePile, dontCheckForAce  if not exists(thePile) then put "cd grp " before thePile    put PileTop(thePile) into theCard    if theCard is empty then return empty  put CardDirection(theCard) into startDirection    if startDirection is "up" then return empty  get CardDirection(theCard,"Up")  return the id of theCard&&the short name of thePile && startDirectionend FlipTopCardfunction MoveToPile thePile, cardList, theDirection, dontAnimate  if not exists(thePile) then put "card group " before thePile    if not exists(thePile) then breakpoint   --¥   if dontAnimate is not empty then lock screen  put the number of lines of cardList into lastLine  put empty into undoList  repeat with i = lastLine down to 1    put the reference of (line i of cardList) into theCard    if not exists(theCard) then breakpoint --¥       put the id of theCard && the short name of the pile of theCard && CardDirection(line 1 of cardList) & "," after undoList          if theDirection is not empty then get CardDirection(theCard, theDirection)      if not the visible of theCard then showCard theCard        RemoveFromPile theCard      AssignCardTo thePile, theCard        bring theCard to front    put PileLoc(thePile) into pileLoc        if dontAnimate is empty then animate theCard from (the loc of theCard) to pileLoc in 2 ticks    else show theCard at pileLoc      end repeat  if last char of undoList is "," then delete last char of undoList  if dontAnimate is not empty then unlock screen  return undoListend MoveToPileon ClearUndoStack  put empty into cd fld "undo"  hide bg btn "undo"end ClearUndoStackfunction BuildUndoString cardList  put empty into returnList    repeat with i = 1 to the number of lines of cardList    put line i of cardList into theCard    put the id of theCard && the short name of the pile of theCard&& CardDirection(theCard) into item i of returnList  end repeat    return returnListend BuildUndoStringon AddToUndoStack undoLine, dontClear  put undoLine & return before cd fld "undo"  if last char of cd fld "undo" is return then delete last char of cd fld "undo"    show bg btn "undo"end AddToUndoStackon Undo  put line 1 of cd fld "undo" into undoLine  if undoLine is empty then exit Undo  repeat with i = the number of items of undoLine down to 1    put item i of undoLine into thisUndo    put "cd bmp id "&word 1 of thisUndo into theCard      put "cd grp "&quote&word 2 of thisUndo&quote into thePile    put word 3 of thisUndo into theDirection    get MoveToPile(thePile, theCard, theDirection)  end repeat  delete line 1 of cd fld "undo"  if cd fld "undo" is empty then hide bg btn "undo"end Undoon animateCard theCard, startLoc, endLoc  bring theCard to front  wait until the isPlaying of bg path 1 is false  set the startPoint of bg path 1 to startLoc  set the endPoint of bg path 1 to endLoc  animate theCard along bg path 1end animateCardon RemoveFromPile theCard  put the id of theCard into theId  put the pile of theCard into thePile  if thePile is empty then exit RemoveFromPile  put the cardList of thePile into cardList  if cardList is empty then return empty  repeat with i = the number of lines of cardList down to 1    if line i of cardList is not theID then next repeat    delete line i of cardList        exit repeat    end repeat  SetCards thePile, StripReturns(cardList)end RemoveFromPilefunction StripReturns theString --¥¥¥¥  if theString is empty then return empty  repeat while last char of theString is return    delete last char of theString  end repeat  return theString  end StripReturns--on idle  --¥¥¥  global gStartTicksif gStartTicks is empty then pass idleif the ticks - gStartTicks > 60 thenput the ticks into gStartTicksif bg fld "Status" is empty then ShowStatus "Hey, you!  Click the deal button!!!"   else ShowStatus empty   end ifpass idleend idleon Lure  global gStartTicks  put the ticks into gStartTicks  end Lureon EndLure  global gStartTicks  put empty into gStartTicks      set the name of bg btn 1 to "Deal"end EndLurefunction CardStrings cardList    repeat with i = the number of lines of cardList down to 1      get CardNames(line i of cardList)         put ValueName(it)&" of "&SuitName(it) into line i of cardList    end repeat    return cardListend CardStringsfunction ColorName theCard  if exists(theCard) then put the short name of theCard into theCard    get offset(char 2 of theCard,"DCHS")   if it is 0 then return empty  return word it of "Red Black Red Black"end ColorNamefunction SuitName theCard  if exists(theCard) then put the short name of theCard into theCard  get offset(char 2 of theCard,"DCHS")  if it is 0 then return empty  return word it of "Diamonds Clubs Hearts Spades"end SuitNamefunction ValueName theCard  if exists(theCard) then put the short name of theCard into theCard  get offset(char 1 of theCard,"234567890JQKA")   if it is 0 then return empty  return word it of "Two Three Four Five Six Seven Eight Nine Ten Jack Queen King Ace"end ValueNamefunction CardValue theCard  if exists(theCard) then put the short name of theCard into theCard  return offset(char 1 of theCard,"234567890JQKA")  end CardValuefunction IsACard theObject  if theObject is empty then put the reference of the target into theObject    return "IsACard" is in the properties of theObject  end IsACardon SortBaseCards  put BaseCardList() into cardList    put SortCards(cardList) into  cardList    repeat with i = the number of lines of cardList down to 1      end repeatend SortBaseCardsfunction SortCards CardList    if cardList is empty then return empty  put empty into sortedList      repeat with i = the number of lines of cardList down to 1    put CardValue(CardNames(line i of cardList)) into theLine    put line i of cardList into line theLine of sortedList    end repeat    put empty into returnList  repeat with i = 1 to the number of lines of sortedList    if line i of sortedList is not empty then put line i of sortedList & return after returnList    end repeat    delete last char of returnList    return returnList  end SortCards  function CardValue thisCard    if the length of thisCard > 2 then put the short name of thisCard into thisCard  put offset(char 1 of thisCard,"234567890JQKA") into valueOffset  put ((offset(char 2 of thisCard,"DCHS")-1)*13) into suitOffset  return suitOffset+valueOffsetend CardValuefunction ValueList  return "234567890JQKA"  end ValueListfunction SuitList  return "SDHC"  end SuitListon ShowStock theState  if theState is empty then put true into theState    if not exists(cd grp "Stock") then exit ShowStock    set the visible of cd grp "Stock" to theState    put PileContents("cd grp Stock") into cardList   if theState then PileCards cardList, the loc of cd grp "Stock"  ShowCards cardList,theStateend ShowStockon HideStock  ShowStock false    end HideStockon MakeStock cardList  if not exists(cd grp "Stock") then    create cd grp    set the name of last cd grp to "Stock"    add property cardList to cd grp "Stock"      end if      AssignCards "cd grp Stock",cardList,"down"end MakeStockon DeleteStock  if exists(cd grp "Stock") then delete cd grp "Stock"    end DeleteStockfunction StockContents  if exists(cd grp "Stock") then return PlayersCards(cd grp "Stock")end StockContentsfunction StockSize  return StockCount()  end StockSizefunction StockCount  if exists(cd grp "Stock") then return the number of lines of the cardList of cd grp "Stock"  else return 0end StockCounton MakePlayers playerCount    if playerCount is empty then exit MakePlayers  StartProgress "Making player # of "&playerCount,1  put "50,120" into startLoc  put (the bottom of this card - 20 - (item 2 of startLoc)) div playerCount into verticalOffset    repeat with i = 1 to playerCount    ShowProgress    create cd grp    set the name of last cd grp to "Player"&i        set the loc of last cd grp to startLoc    show last cd grp    add verticalOffset to item 2 of startLoc        add property IsCardPlayer to last cd grp    add property CardList to last cd grp      end repeat   EndProgressend MakePlayerson DeletePlayers  get PlayerList()  StartProgress "Deleting player # of "&the number of lines of it    DeleteObjectList it, "ShowProgress"  EndProgressend DeletePlayerson ShowPile thePile    showCards PileContents(thePile)end ShowPilefunction CardDirection theCard, newDirection    if not exists(theCard) then breakpoint --¥  if newDirection is not empty then     set the IsACard of theCard to newDirection      if the visible of theCard then ShowCard theCard  end if  get the IsACard of theCard  if it is empty then return "Up"  else return it  end CardDirectionon SetCards thePile, cardList  set the cardList of thePile to cardList  end SetCardson AssignCards thePile, cardList, theDirection    put the cardList of thePile into originalList  repeat with i = 1 to the number of lines of cardList    put line i of cardList into thisCard    if theDirection is not empty then get CardDirection(thisCard,theDirection)    put the id of thisCard into line i of cardList          set the pile of thisCard to thePile      end repeat  if last char of originalList is not return then put return after originalList    set the cardList of thePile to originalList&cardList  end AssignCardson AssignCardTo thePile, theCard, theDirection  if not exists(thePile) then put "card group " before thePile  if not exists(thePile) then breakpoint    if not exists(theCard) then breakpoint      put the cardList of thePile into theList  put the id of theCard into line (the number of lines of theList + 1) of theList    set the cardList of thePile to theList  if theDirection is not empty then get CardDirection(theCard,theDirection)    set the pile of theCard to thePileend AssignCardTofunction PileTop thePile  if not exists(thePile) then put "Card group " before thePile  if not exists(thePile) then breakpoint --¥  put last line of the cardList of thePile into pileTop  if pileTop is empty then return empty  else return "cd bmp id "&pileTop  end PileTopfunction PileCount thePile  if not exists(thePile) then put "card group " before thePile  if not exists(thePile) then breakpoint --¥  return the number of lines of the cardList of thePile  end PileCountfunction PileContents thePile  if not exists(thePile) then put "Card group " before thePile  if not exists(thePile) then breakpoint --¥    put the cardList of thePile into cardList  repeat with i = 1 to the number of lines of cardList    put "card bitmap id " before line i of cardList    end repeat  return cardListend PileContentsfunction Shuffle    return ShuffleCards(CardList())end Shufflefunction ShuffleCards cardList  if cardList is empty then put CardList() into cardList    put the number of lines of cardList into lastCard  put empty into returnList    StartProgress lastCard,"Shuffling"  repeat with i = lastCard down to 1    ShowProgress    get random(i)    put line it of cardList into line i of returnList    set the pile of (line it of cardList) to empty    delete line it of cardList  end repeat        ClearProgress    return returnListend ShuffleCardsfunction CardNames cardList  if cardList is empty then put BaseCardList() into cardList    repeat with i = 1 to the number of lines of cardList    put the short name of (line i of cardList) into line i of cardList        end repeat      return cardListend CardNameson ShowCard theCard, theLoc, theDirection  if theDirection is empty then put the IsACard of theCard into theDirection  if theDirection is empty then put "Down" into theDirection  set the IsACard of theCard to theDirection    if theDirection is "Down" then do "put bg bmp back into "&theCard  else do "put bg bmp "&quote&the short name of theCard&quote&" into "&theCard    if theLoc is not empty then show theCard at theLoc  else show theCard end ShowCardon HideCard theCard  hide theCardend HideCardon QuickShowCards cardList, theLoc, theDirection    repeat with i = 1 to the number of lines of cardList    ShowProgress    put line i of cardList into theCard    set the loc of theCard to theloc    if theDirection is not empty then set the IsACard of theCard to theDirection    if the IsACard of theCard is "Down" then do "put bg bmp back into "&theCard    else do "put bg bmp "&quote&the short name of theCard&quote&" into "&theCard    show theCard  end repeatend QuickShowCardson ShowCards cardList, theLoc, theDirection  lock screen  if theState is empty then put true into theState  if cardList is empty then put CardList() into cardList  repeat with i = the number of lines of cardList down to 1    ShowProgress    ShowCard line i of cardList, theLoc, theDirection    end repeat  unlock screenend ShowCardson HideCards cardList    lock screen  if cardList is empty then put CardList() into cardList    repeat with i = the number of lines of cardList down to 1      ShowProgress    put line i of cardList into thisCard    hide thisCard      end repeat  unlock screenend HideCardsfunction CardList  return the list of cd bmps with property IsACardend CardListfunction PileRank theCard  put the pile of theCard into thePile  put the id of theCard into cardID  put the cardList of thePile into pileList  repeat with i = the number of lines of pileList down to 1    if line i of pileList is cardID then return i        end repeat  return 0 end PileRankfunction PileName theCard  return the short name of (the pile of theCard)  end PileNamefunction WhichPile theLoc  put PileList() into pileList  repeat with i = the number of lines of pileList down to 1    if theLoc is within the rect of (line i of pileList) then return (line i of pileList)  end repeatend WhichPilefunction NewShuffle numberOfDecks  DeleteCards  MakeDecks numberOfDecks  return CardList()  end NewShuffleon DeleteCards  put the list of cd bmps with property IsACard into cardList  put the number of lines of cardList into lastLine    StartProgress "Deleting card # of "&CardCount(),10  repeat with i = lastLine down to 1    ShowProgress    delete (line i of cardList)  end repeat    EndProgressend DeleteCardson MakeDeck numDecks  if numDecks is empty then put 1 into numDecks  StartProgress "Making card # of "&numDecks*BaseCardCount()  ,13  repeat with i = 1 to numDecks    MakeCards  end repeat    EndProgressend MakeDeckon MakeCards cardList  if cardList is empty then put ShuffleCards(BaseCardList()) into cardList  repeat with i = 1 to the number of lines of cardList    ShowProgress    put the name of (line i of cardList) into thisCard    create card bitmap    add property IsACard to last cd bmp    add property Pile to last cd bmp        add property IsWild to last cd bmp    set the name of last cd bmp to (the short name of thisCard)    do "put "&thisCard&" into last cd bmp"  end repeatend MakeCardsfunction BaseCardGroups  return "bg grp hearts"&return&"bg grp clubs"&return&"bg grp spades"&return&"bg grp diamonds"end BaseCardGroupson DeleteBaseCards  put BaseCardList() into cardList  StartProgress "Deleting base card # of "&the number of lines of cardList    repeat with i = the number of lines of cardList down to 1    ShowProgress    delete (line i of cardList)  end repeat      EndProgressend DeleteBaseCardson ShowBaseCards theState  if theState is empty then put true into theState  put BaseCardList() into cardList  put the number of lines of cardList into lastLine    if theState then    repeat with i = 1 to lastLine      set the visible of (line i of cardList) to theState      end repeat        else    repeat with i = lastLine down to 1      set the visible of (line i of cardList) to theState      end repeat    end ifend ShowBaseCardson HideBaseCards  ShowBaseCards false  end HideBaseCardsfunction BaseCardList  return the list of bg bmps with property IsBaseCard  end BaseCardListfunction BaseCardCount  return the number lines of the list of bg bmps with property IsBaseCardend BaseCardCounton ImportBaseCards  DeleteBaseCards  ImportFolder empty,"bg","Select a card in the new deck...","add property IsBaseCard to theObject"  end ImportBaseCardsfunction CardCount  return the number of lines of the list of cd bmps with property IsACard  end CardCountfunction CurrentStatusLevel  global gRTLstatusLevel  if gRTLstatusLevel is empty then put 1 into gRTLstatusLevel  return gRTLstatusLevelend CurrentStatusLevelon ShowStatus theMessage, theLevel  if not exists(bg fld "Status") then exit ShowStatus  if theMessage is not empty then    if theLevel is not empty and StatusLevel(theLevel) > CurrentStatusLevel() then exit ShowStatus    put theMessage into bg fld "Status"    exit ShowStatus    end if    if "statusCode" is not in the properties of the target then exit ShowStatus  put the statusCode of the target into statusCode  if statusCode is empty then exit ShowStatus    global gRTLleaveScript  put ((the number of lines of statusCode) + 1) div 5 into lastStatus  put the rect of the target into targetRect   repeat with i = 1 to lastStatus    if the mouseLoc is not within targetRect then exit repeat    put (i-1) * 5 into statusOffset    if line (statusOffset + 1) of statusCode > CurrentStatusLevel() then next repeat    get line (statusOffset + 2) of statusCode          if it is empty then put true into condition    else      if word 1 of it is "global" then        do it        do "put "&word 2 of it&" into condition"      else send "put "&it&" into condition" to the target    end if        if condition is true then      put line (statusOffset + 3) of statusCode into bg fld "Status"      do line (statusOffset + 4) of statusCode      put line (statusOffset + 5) of statusCode into gRTLleaveScript            exit repeat          end if      end repeatend ShowStatuson ClearStatus  global gRTLleaveScript  if gRTLleaveScript is not empty then do gRTLleaveScript  put empty into gRTLleaveScript  if exists(bg fld "Status") then put empty into bg fld "Status"end ClearStatusfunction StatusLevelCodes  return "Always"&return&"Help"&return&"Debug"end StatusLevelCodesfunction StatusLevel statusLevelCode  if statusLevelCode is in "123" then return statusLevelCode  return the number of lines in char 1 to (offset(statusLevelCode,StatusLevelCodes())) of StatusLevelCodes()end StatusLevelfunction StatusLevelCode statusLevel  return item statusLevel of "Always,Help,Debug"end StatusLevelCodeon StatusLine theLevel  get CurrentStatusLevel(StatusLevel(theLevel))    end StatusLine---==========================------    Progress bar stuff!---==========================---function ShowingProgress  if not exists(bg shp "progress") then return false  return the progressMessage of bg shp "progress" is not empty  end ShowingProgresson ShowProgress  set the cursor to busy    if not exists(bg shp "progress") then exit AdvanceProgress  if the currentCount of bg shp "progress" >= the totalCount of bg shp "progress" then exit ShowProgress    set the currentCount of bg shp "progress" to (the currentCount of bg shp "progress" + 1)    put the rect of bg shp "progress" into theRect  put item 1 of theRect + round(the currentCount of bg shp "progress" * the stepWidth of bg shp "progress") into item 3 of theRect  set the rect of bg shp "progress" to theRect  end ShowProgresson StartProgress totalCount, theMessage, statusLevel  set the cursor to busy    if exists(bg shp "progress") and StatusLevel(statusLevel) < CurrentStatusLevel() then     put the rect of bg shp "progress" into theRect    if totalCount is empty then             if theMessage is not empty then         set the progressMessage of bg shp "progress" to theMessage        set the progressStatusLevel of bg shp "progress" to statusLevel        ShowStatus theMessage, statusLevel      end if            ShowProgress    else      set the totalCount of bg shp "progress" to totalCount      set the currentCount of bg shp "progress" to 0        set the stepWidth of bg shp "progress" to the totalWidth of bg shp "progress" / totalCount          if exists(bg shp "progressEnd") then show bg shp "progressEnd"      ShowStatus theMessage, statusLevel            put item 1 of theRect + 1 into item 3 of theRect        set the rect of bg shp "progress" to theRect         show bg shp "progress"    end if  end ifend StartProgresson ClearProgress theMessage, statusLevel  set the cursor to browse  if exists(bg shp "progressEnd") then hide bg shp "progressEnd"  if exists(bg shp "progress") then     hide bg shp "progress"    set the progressMessage of bg shp "progress" to empty         set the progressStatusLevel of bg shp "progress" to empty    end if  if theMessage is not empty then ShowStatus theMessage, statusLevel  else ClearStatus  end ClearProgress  