on idle  CheckForNextMoveToAce    pass idleend idleon CheckForNextMoveToAce thePile  if the hilite of cd btn "automatically move to aces" is false then exit CheckForNextMoveToAce  global gCDactiveSlotList  if gCDactiveSlotList is empty then put "cd grp discard" & return & SlotList() into gCDactiveSlotList  if thePile is empty then    put line 1 of gCDactiveSlotList into thePile    delete line 1 of gCDactiveSlotList  end if    if not exists(thePile) then put "cd grp " before thePile  put PileTop(thePile) into theCard  if theCard is empty then exit CheckForNextMoveToAce  if cardDirection(theCard) is "Down" then exit CheckForNextMoveToAce    if IsGoalTop(theCard) then    set the cursor to watch    ShowStatus "Moved "&CardStrings(theCard)&" to the "&SuitName(theCard)&" pile."    put MoveToPile(SuitName(theCard),theCard) into undoList    get FlipTopCard(thePile, "dontCheck")    if it is not empty then put ","&it after undoList    AddToUndoStack undoList    CheckWinCondition  end ifend CheckForNextMoveToAceon mouseDown  ClearStatus  if not IsACard(the target) then pass mouseDown  put the target into theCard  global gCDstartLoc  put the loc of theCard into gCDstartLoc   if cardDirection(theCard) is "Down" then exit mouseDown    put PileRank(theCard) into cardRank  put the pile of theCard into thePile  put PileCount(thePile) into lastRank    if cardRank is lastRank then    bring the target to front  else      set the members of cd grp "MoveGroup" to empty    set the rect of cd grp "MoveGroup" to the rect of theCard    put line cardRank to lastRank of PileContents(thePile) into cardList    lock screen    repeat with i = 1 to the number of lines of cardList        bring (line i of cardList) to front    end repeat    bring cd grp "MoveGroup" to front    unlock screen    set the members of cd grp "MoveGroup" to cardList    show cd grp "MoveGroup"  end ifend mouseDownon mouseStillDown  if not IsACard(the target) then pass mouseStillDown      put the target into theCard  if cardDirection(theCard) is "Down" then  exit mouseStillDown    if the visible of cd grp "MoveGroup" then    set the loc of cd grp "MoveGroup" to the mouseLoc    else set the loc of thecard to the mouseLocend mouseStillDownon mouseUp  if not IsACard(the target) then pass mouseUp  put the target into theCard    put the pile of theCard into thePile    if the short name of thePile is "Stock" then     StockFlip    exit mouseUp  end if    if cardDirection(theCard) is "Down" then     if PileRank(theCard) is PileCount(thePile) then ShowCard theCard,empty,"Up"    exit mouseUp    end if    global gCDstartLoc  put WhichPile(the mouseLoc) into newPile      if the visible of cd grp "MoveGroup" then    if newPile is empty or not IsLegalMove(newPile, theCard) then      animate cd grp "MoveGroup" from the loc of the target to gCDstartLoc in 20 ticks natural    else      put the pile of theCard into startPile      put the members of cd grp "MoveGroup" into cardList      lock screen      put empty into undoList      repeat with i = 1 to the number of lines of cardList        put MoveToPile(newPile,line i of cardList,empty,"dontAnimate")&"," before undoList      end repeat        unlock Screen      get FlipTopCard(thePile)      if it is not empty then put it after undoList      if last char of undoList is "," then delete last char of undoList      AddToUndoStack undoList      CheckWinCondition          end if    set the members of cd grp "MoveGroup" to empty    hide cd grp "MoveGroup"        else    if newPile is empty or not IsLegalMove(newPile,theCard) then      animate theCard from the loc of the target to gCDstartLoc in 20 ticks natural        else                  put MoveToPile(newPile, theCard) into undoList      get FlipTopCard(thePile)      if it is not empty then put ","& it after undoList      AddToUndoStack undoList            CheckWinCondition    end if  end ifend mouseUpon CheckWinCondition  if WinCondition() then answer "You Won!"  end CheckWinConditionfunction WinCondition  put SlotList() into slotList  repeat with i = the number of lines of slotList down to 1    if the cardList of (line i of slotList) is not empty then return false  end repeat    return the number of lines of the cardList of cd grp "discard" is 0end WinConditionon doubleClick  if not IsACard(the target) then pass doubleClick  put the target into theCard    set the cursor to watch  if PileName(theCard) is "stock" then exit doubleClick --StockFlip  put PileRank(theCard) into cardRank  put the pile of theCard into thePile  put PileCount(thePile) into lastRank    set the cursor to watch  put FirstLegalMove(theCard) into theMove  if theMove is empty then    beep  else    if cardRank is lastRank then      put MoveToPile(theMove, theCard) into undoList    else      put line cardRank to lastRank of PileContents(thePile) into cardList      lock screen      put empty into undoList      repeat with i = 1 to the number of lines of cardList        put ","&MoveToPile(theMove,line i of cardList,empty,dontAnimate) before undoList      end repeat        unlock Screen    end if    get FlipTopCard(thePile)    if it is not empty then put ","&it after undoList    if char 1 of undoList is "," then delete char 1 of undoList    AddToUndoStack undoList    CheckWinCondition  end ifend doubleClickfunction IsGoalTop theCard  return CardValue(PileTop(SuitName(theCard))) + 1 is CardValue(theCard)  end IsGoalTopfunction FirstLegalMove theCard  if CardDirection(theCard) is "Down" then return empty  --¥?  put SlotList() into slotList  put the reference of cd grp SuitName(the short name of theCard) & return before slotList    repeat with i = 1 to the number of lines of slotList      if IsLegalMove(line i of slotList, theCard) then return line i of slotList    end repeat    return emptyend FirstLegalMovefunction LegalMoves theCard  if CardDirection(theCard) is "Down" then return empty  --¥?  put SlotList() into slotList  put the reference of cd grp SuitName(theCard) & return before slotList    repeat with i = the number of lines of slotList down to 1    put line i of slotList into thePile    if not IsLegalMove(thePile, theCard) then delete line i of slotList    end repeat  return slotListend LegalMovesfunction IsLegalMove thePile, theCard  if thePile is empty then return false  if not exists(thePile) then put "card group " before thePile  if not exists(thePile) then breakpoint --¥      put the short name of thePile into pileName  put last line of PileContents(thePile) into pileTop    put SuitName(theCard) into cardSuit  put SuitName(pileTop) into pileSuit    put ColorName(theCard) into cardColor  put ColorName(pileTop) into pileColor    put CardValue(pileTop) into pileValue      put CardValue(theCard) into cardValue    if cardSuit is pileName then    if (pileValue + 1) is not cardValue then return false        return true  end if  if pileValue is 0 and cardValue is 13 then return true    if (pileValue - 1) is not cardValue then return false    if cardColor is not pileColor then return true    return false  end IsLegalMovefunction CardValue theCard  if exists(theCard) then put the short name of theCard into theCard  return offset(char 1 of theCard,"A234567890JQK")  end CardValueon StockFlip  set the cursor to watch  put PileContents("stock") into pileList  repeat with i = 1 to 3    if the number of lines of pileList = 0 then exit StockFlip      put MoveToPile("discard",(last line of pileList),"Up") into item i of undoList    delete last line of pileList  end repeat  AddToUndoStack undoList  CheckForNextMoveToAce "cd grp discard"  end StockFlipon ResetStock  set the cursor to watch  put PileContents("discard") into cardList  AddToUndoStack MoveToPile("cd grp stock",cardList,"down",dontanimate)   SetCards "cd grp discard",emptyend ResetStock